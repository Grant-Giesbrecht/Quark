#ISV_SERIES PT
#ARCHITECTURE Matterhorn821

//This file specifies the computer's instructions
//Format:
//
// * <Instruction_Name (str)> <opcode (int)> <num_data_bytes (int)>

// *********************** ALU INSTRUCTIONS **********************************

* ADD 1 0
#REPL FETCH
2: ALU_ADD REGC_WR FLAG_ADD_SET PHSC_RST

* SUBTRACT 2 0
#REPL FETCH
2: ALU_ADD CARRY_IN INV_B REGC_WR PHSC_RST

* AND 3 0
#REPL FETCH
2: AND_EN REGC_WR PHSC_RST

// *************************** FCP INSTRUCTIONS *******************************

* MULT 4 0
#REPL FETCH
2: FCP_OPCD0=ON FCP_OPCD1=OFF FCP_OPCD2=OFF FCP_TRIG PHSC_RST //Note: The FCP opcode is made up and def wrong, same with FCP flags

// *************************** CONTROL FLOW INSTRUCTIONS **********************

*  KEYPAD_INTERRUPT 5 0
#REPL FETCH
2: PC_OE REGIRTN_WR IN_ISR_SET
3: KEY_OE PC_WR
4: KEY_INT_CLR PHSC_RST

* TIMER_INTERRUPT 6 0
#REPL FETCH
2: PC_OE REGIRTN_WR
3: REGTISR_OE PC_WR FLG_TIMINT_CLR PHSC_RST

//NOTE: This is not an instruction. The CPU decodes the instruction of JUMP_IF_
// ZERO and CARRY to JUMP_IS_TRUE or JUMP_IS_FALSE. Use the aforementioned
// instructions. These operations will be executed if the condition is true.
//
* JUMP_IS_TRUE 7 2
"Takes a 16b address as jump location"
//Note: Should be the same as "JUMP"
//Note: This does NOT add to the stack
#REPL FETCH
2: PC_OE R0_MAR F0_MAR F1_MAR F_OPCD0=OFF F_OPC1=ON PMEM_TRIG
3: PMEM_OE AA0_WR PC_CLK
4: PC_OE R0_MAR F0_MAR F1_MAR F_OPCD0=OFF F_OPC1=ON PMEM_TRIG
5: PMEM_OE AA8_WR PC_CLK
6: AA_OE PC_WR PHSC_RST

* JUMP_IS_FALSE 8 2
#REPL FETCH
2: PC_CLK
3: PC_CLK PHSC_RST

* RETURN 9 0
#REPL FETCH
2: REGSTK_DN
3: REGSTK_OE R1_MAR
4: R1_OE AA8 REGSTK_DN
5: REGSTK_OE R1_MAR
6: R1_OE AA0
7: AA_OE PC_WR PHSC_RST

// *************************** CONTROL FLOW INSTRUCTIONS **********************
* R0_REGA 10 2
"Takes a 16b address as RAM address to move"
#REPL FETCH
2: PC_OE R0_MAR F0_MAR F1_MAR F_OPCD0=OFF F_OPC1=ON PMEM_TRIG
3: PMEM_OE AA0_WR PC_CLK
4: PC_OE R0_MAR F0_MAR F1_MAR F_OPCD0=OFF F_OPC1=ON PMEM_TRIG
5: PMEM_OE AA8_WR PC_CLK
6: AA_OE R0_MAR
7: R0_OE REGA_WR PHSC_RST

* PMEM_REGA 11 2
"Takes a 16b address as RAM address to move"
#REPL FETCH
2: PC_OE R0_MAR F0_MAR F1_MAR F_OPCD0=OFF F_OPC1=ON PMEM_TRIG
3: PMEM_OE AA0_WR PC_CLK
4: PC_OE R0_MAR F0_MAR F1_MAR F_OPCD0=OFF F_OPC1=ON PMEM_TRIG
5: PMEM_OE AA8_WR PC_CLK
6: AA_OE R0_MAR F0_MAR F1_MAR F_OPCD0=OFF F_OPC1=ON PMEM_TRIG
7: PMEM_OE REGA_WR PHSC_RST

* CC_REGA 12 0
#REPL FETCH
2: CCA_OE REGA_WR PHSC_RST

* REGSYS_REGA 13 0
#REPL FETCH
2: REGSYS_OE REGA_WR PHSC_RST

//TODO: The ones below here are wrong because they're trying to write 8 bits to alpha, not 32

* R0_REGK 14 2
"Takes a 16b address as RAM address to move, along with the 3 following bytes.
Moves a 32 bits into Kappa"
#REPL FETCH
#REPL GETADDR
6: PC_OE IRTN_WR
7: AA_OE PC_WR R0_MAR
8: R0_OE REGK0 PC_CLK
9: PC_OE R0_MAR
10: R0_OE REGK1 PC_CLK
11: PC_OE R0_MAR
12: R0_OE REGK2 PC_CLK
13: PC_OE R0_MAR
14: R0_OE REGK3
15: IRTN_OE PC_WR PHSC_RST

* PMEM_REGK 15 2
"Takes a 16b address as PMEM address to move, along with the 3 following bytes.
Moves a 32 bits into Kappa"
#REPL FETCH
#REPL GETADDR
6: PC_OE IRTN_WR
7: AA_OE PC_WR R0_MAR F0_MAR F1_MAR F_OPCD0=OFF F_OPC1=ON PMEM_TRIG
8: PMEM_OE REGK0_WR PC_CLK
9: PC_OE R0_MAR F0_MAR F1_MAR F_OPCD0=OFF F_OPC1=ON PMEM_TRIG
10: PMEM_OE REGK1_WR PC_CLK
11: PC_OE R0_MAR F0_MAR F1_MAR F_OPCD0=OFF F_OPC1=ON PMEM_TRIG
12: PMEM_OE REGK2_WR PC_CLK
13: PC_OE R0_MAR F0_MAR F1_MAR F_OPCD0=OFF F_OPC1=ON PMEM_TRIG
14: PMEM_OE REGK3_WR
15: IRTN_OE PC_WR PHSC_RST

* CC32_REGK 16 0
#REPL FETCH
2: CC0_OE REGK0
3: CC1_OE REGK1
4: CC2_OE REGK2
5: CC3_OE REGK3 PHSC_RST

* CC8_REGK 17 0
#REPL FETCH
2: CC0_OE REGK0 PHSC_RST

* REGK_CC32 18 0
#REPL FETCH
2: REGK0_OE CC0_WR
3: REGK1_OE CC1_WR
4: REGK2_OE CC2_WR
5: REGK3_OE CC3_WR PHSC_RST

* CC32_R0 19 2
"Moves the contents of cache to R0 at the specified address"
#REPL FETCH
#REPL GETADDR
6: PC_OE IRTN_WR
7: AA_OE R0_MAR PC_WR
8: CC0_OE R0_WR PC_CLK
9: PC_OE R0_MAR
10: CC1_OE R0_WR PC_CLK
11: PC_OE R0_MAR
12: CC2_OE R0_WR PC_CLK
13: PC_OE R0_MAR
14: CC3_OE R0_WR
15: IRTN_OE PC_WR PHSC_RST

// * PMEM_ALPHA 15 2
// #REPL FETCH
// #REPL GETADDR
// 6: AA_OE R0_MAR F0_MAR F1_MAR F_OPCD0=OFF F_OPC1=ON PMEM_TRIG
// 7: PMEM_OE REGALPHA_WR

* CC4_ALPHA 16 0
#REPL FETCH
2: CCA_ALPHA0
3:

* SET_PMEM_EXT 17 0
#REPL FETCH
2: PMEM_EXT_SET PHSC_RST


* FCPA_CACHE 48 0
0: PC_OE PMEM_MAR
1: FLSH_OPC0=OFF FLSH_OPC1=ON FLSH0_TRIG
2: REGINS_WR FLSH0_OE PC_CLK
3: FCPC0_OE CCA_WR
4: FCPC1_OE CCB_WR
5: FCPC2_OE CCC_WR
6: FCPC3_OE CC3_WR PHSC_RST

* CACHE32_RAM 49 2
0: PC_OE PMEM_MAR
1: FLSH_OPC0=OFF FLSH_OPC1=ON FLSH0_TRIG
2: REGINS_WR FLSH0_OE PC_CLK
3: PC_OE JRTN_WR PC_CLK //SAVE PROGRAM LINE
4: PC_OE PMEM_OE AA0_WR PC_CLK //GET 1ST BYTE OF RAM ADDR
5: PC_OE PMEM_OE AA8_WR PC_CLK // GET 2ND BYTE OF RAM ADDR
6: AA_OE PC_WR //MOVE RAM ADDR TO COUNTER
7: PC_OE CCA_OE RAM_WR PC_CLK
8: PC_OE CCB_OE RAM_WR PC_CLK
9: PC_OE CCC_OE RAM_WR PC_CLK
10: PC_OE CCD_OE RAM_WR PC_CLK //DATA HAS BEEN MOVED
11: JRTN_OE PC_WR PHSC_RST



// Blocks
#DEF FETCH //Combined
0: PC_OE F0_MAR F1_MAR R0_MAR F_OPCD0=OFF F_OPC1=ON PMEM_TRIG
1: PMEM_OE REGINS_WR PC_CLK
#END

#DEF GETADDR
2: PC_OE R0_MAR F0_MAR F1_MAR F_OPCD0=OFF F_OPC1=ON PMEM_TRIG
3: PMEM_OE AA0_WR PC_CLK
4: PC_OE R0_MAR F0_MAR F1_MAR F_OPCD0=OFF F_OPC1=ON PMEM_TRIG
5: PMEM_OE AA8_WR PC_CLK
#END







//
//
// #DEF FETCH //This is an example of what fetch should look like for flash as pmem
// 0: PC_OE F0_MAR F1_MAR
// 1: F_OPC0=OFF F_OPC1=ON F0_TRIG
// 2: PMEM_OE REGINS_WR PC_CLK
//
// 0: PC_OE F0_MAR F1_MAR F_OPC0=OFF F_OPC1=ON F0_TRIG
// 1: PMEM_OE REGINS_WR PC_CLK
// #END
//
// #DEF FETCH //This is an example of what fetch should look like for ram as pmem
// 0: PC_OE R0_MAR
// 1: R0_OE REGINS_WR PC_CLK
// 2:
// #END
